
Debugger.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000974  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000178  00800060  00000974  00000a08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000fc  008001d8  008001d8  00000b80  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b80  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000160  00000000  00000000  00000bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000107d  00000000  00000000  00000d10  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000635  00000000  00000000  00001d8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000830  00000000  00000000  000023c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002c8  00000000  00000000  00002bf4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000403  00000000  00000000  00002ebc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000070b  00000000  00000000  000032bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000120  00000000  00000000  000039ca  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	db c2       	rjmp	.+1462   	; 0x5ba <__vector_1>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	11 e0       	ldi	r17, 0x01	; 1
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e4 e7       	ldi	r30, 0x74	; 116
  3a:	f9 e0       	ldi	r31, 0x09	; 9
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	a8 3d       	cpi	r26, 0xD8	; 216
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_H__>

00000048 <__do_clear_bss>:
  48:	22 e0       	ldi	r18, 0x02	; 2
  4a:	a8 ed       	ldi	r26, 0xD8	; 216
  4c:	b1 e0       	ldi	r27, 0x01	; 1
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a4 3d       	cpi	r26, 0xD4	; 212
  54:	b2 07       	cpc	r27, r18
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	ed d2       	rcall	.+1498   	; 0x634 <main>
  5a:	8a c4       	rjmp	.+2324   	; 0x970 <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <init_communication>:
uint8_t bit_buffer = 0;
unsigned char paused = 0;

void init_communication(void) { //TODO: rename (zeile 31)
	//Datenpins initialisieren
	DDRD &= ~(1<<2); //Clock Pin
  5e:	8a 98       	cbi	0x11, 2	; 17
	PORTD|=(1<<2);
  60:	92 9a       	sbi	0x12, 2	; 18
	
	DDRD &= ~(1<<3); //Data Pin
  62:	8b 98       	cbi	0x11, 3	; 17
	PORTD|=(1<<3);
  64:	93 9a       	sbi	0x12, 3	; 18
	MCUCR |= (1<<ISC01) | (1<<ISC00); //Steigende Flanke, Interrupt (INT0) für Datentakt
  66:	85 b7       	in	r24, 0x35	; 53
  68:	83 60       	ori	r24, 0x03	; 3
  6a:	85 bf       	out	0x35, r24	; 53
	GICR  |= (1<<INT0);
  6c:	8b b7       	in	r24, 0x3b	; 59
  6e:	80 64       	ori	r24, 0x40	; 64
  70:	8b bf       	out	0x3b, r24	; 59
  72:	08 95       	ret

00000074 <dict_initialization>:
}

void dict_initialization() {
		//Index von Befehlen ist kleiner als 32
	
		ascii[32] = " "; //Sonderzeichen
  74:	85 ed       	ldi	r24, 0xD5	; 213
  76:	91 e0       	ldi	r25, 0x01	; 1
  78:	90 93 1f 02 	sts	0x021F, r25
  7c:	80 93 1e 02 	sts	0x021E, r24
		ascii[33] = "!";
  80:	83 ef       	ldi	r24, 0xF3	; 243
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	90 93 21 02 	sts	0x0221, r25
  88:	80 93 20 02 	sts	0x0220, r24
		ascii[34] = "\"";
  8c:	85 ef       	ldi	r24, 0xF5	; 245
  8e:	90 e0       	ldi	r25, 0x00	; 0
  90:	90 93 23 02 	sts	0x0223, r25
  94:	80 93 22 02 	sts	0x0222, r24
		ascii[35] = "#";
  98:	27 ef       	ldi	r18, 0xF7	; 247
  9a:	30 e0       	ldi	r19, 0x00	; 0
  9c:	30 93 25 02 	sts	0x0225, r19
  a0:	20 93 24 02 	sts	0x0224, r18
		ascii[36] = "$";
  a4:	29 ef       	ldi	r18, 0xF9	; 249
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	30 93 27 02 	sts	0x0227, r19
  ac:	20 93 26 02 	sts	0x0226, r18
		ascii[37] = "%";
  b0:	2b ef       	ldi	r18, 0xFB	; 251
  b2:	30 e0       	ldi	r19, 0x00	; 0
  b4:	30 93 29 02 	sts	0x0229, r19
  b8:	20 93 28 02 	sts	0x0228, r18
		ascii[38] = "&";
  bc:	2d ef       	ldi	r18, 0xFD	; 253
  be:	30 e0       	ldi	r19, 0x00	; 0
  c0:	30 93 2b 02 	sts	0x022B, r19
  c4:	20 93 2a 02 	sts	0x022A, r18
		ascii[39] = "'";
  c8:	2f ef       	ldi	r18, 0xFF	; 255
  ca:	30 e0       	ldi	r19, 0x00	; 0
  cc:	30 93 2d 02 	sts	0x022D, r19
  d0:	20 93 2c 02 	sts	0x022C, r18
		ascii[40] = "(";
  d4:	21 e0       	ldi	r18, 0x01	; 1
  d6:	31 e0       	ldi	r19, 0x01	; 1
  d8:	30 93 2f 02 	sts	0x022F, r19
  dc:	20 93 2e 02 	sts	0x022E, r18
		ascii[41] = ")";
  e0:	23 e0       	ldi	r18, 0x03	; 3
  e2:	31 e0       	ldi	r19, 0x01	; 1
  e4:	30 93 31 02 	sts	0x0231, r19
  e8:	20 93 30 02 	sts	0x0230, r18
		ascii[42] = "*";
  ec:	25 e0       	ldi	r18, 0x05	; 5
  ee:	31 e0       	ldi	r19, 0x01	; 1
  f0:	30 93 33 02 	sts	0x0233, r19
  f4:	20 93 32 02 	sts	0x0232, r18
		ascii[43] = "+";
  f8:	27 e0       	ldi	r18, 0x07	; 7
  fa:	31 e0       	ldi	r19, 0x01	; 1
  fc:	30 93 35 02 	sts	0x0235, r19
 100:	20 93 34 02 	sts	0x0234, r18
		ascii[44] = ",";
 104:	29 e0       	ldi	r18, 0x09	; 9
 106:	31 e0       	ldi	r19, 0x01	; 1
 108:	30 93 37 02 	sts	0x0237, r19
 10c:	20 93 36 02 	sts	0x0236, r18
		ascii[45] = "-";
 110:	2b e0       	ldi	r18, 0x0B	; 11
 112:	31 e0       	ldi	r19, 0x01	; 1
 114:	30 93 39 02 	sts	0x0239, r19
 118:	20 93 38 02 	sts	0x0238, r18
		ascii[46] = ".";
 11c:	2d e0       	ldi	r18, 0x0D	; 13
 11e:	31 e0       	ldi	r19, 0x01	; 1
 120:	30 93 3b 02 	sts	0x023B, r19
 124:	20 93 3a 02 	sts	0x023A, r18
		ascii[47] = "/";
 128:	2f e0       	ldi	r18, 0x0F	; 15
 12a:	31 e0       	ldi	r19, 0x01	; 1
 12c:	30 93 3d 02 	sts	0x023D, r19
 130:	20 93 3c 02 	sts	0x023C, r18
		
		ascii[58] = ":";
 134:	21 e1       	ldi	r18, 0x11	; 17
 136:	31 e0       	ldi	r19, 0x01	; 1
 138:	30 93 53 02 	sts	0x0253, r19
 13c:	20 93 52 02 	sts	0x0252, r18
		ascii[59] = ";";
 140:	23 e1       	ldi	r18, 0x13	; 19
 142:	31 e0       	ldi	r19, 0x01	; 1
 144:	30 93 55 02 	sts	0x0255, r19
 148:	20 93 54 02 	sts	0x0254, r18
		ascii[60] = "<";
 14c:	25 e1       	ldi	r18, 0x15	; 21
 14e:	31 e0       	ldi	r19, 0x01	; 1
 150:	30 93 57 02 	sts	0x0257, r19
 154:	20 93 56 02 	sts	0x0256, r18
		ascii[61] = "=";
 158:	27 e1       	ldi	r18, 0x17	; 23
 15a:	31 e0       	ldi	r19, 0x01	; 1
 15c:	30 93 59 02 	sts	0x0259, r19
 160:	20 93 58 02 	sts	0x0258, r18
		ascii[62] = ">";
 164:	29 e1       	ldi	r18, 0x19	; 25
 166:	31 e0       	ldi	r19, 0x01	; 1
 168:	30 93 5b 02 	sts	0x025B, r19
 16c:	20 93 5a 02 	sts	0x025A, r18
		ascii[63] = "?";
 170:	2b e1       	ldi	r18, 0x1B	; 27
 172:	31 e0       	ldi	r19, 0x01	; 1
 174:	30 93 5d 02 	sts	0x025D, r19
 178:	20 93 5c 02 	sts	0x025C, r18
		ascii[64] = "@";
 17c:	2d e1       	ldi	r18, 0x1D	; 29
 17e:	31 e0       	ldi	r19, 0x01	; 1
 180:	30 93 5f 02 	sts	0x025F, r19
 184:	20 93 5e 02 	sts	0x025E, r18
		
		ascii[91] = "[";
 188:	2f e1       	ldi	r18, 0x1F	; 31
 18a:	31 e0       	ldi	r19, 0x01	; 1
 18c:	30 93 95 02 	sts	0x0295, r19
 190:	20 93 94 02 	sts	0x0294, r18
		ascii[92] = "\"";
 194:	90 93 97 02 	sts	0x0297, r25
 198:	80 93 96 02 	sts	0x0296, r24
		ascii[93] = "]";
 19c:	81 e2       	ldi	r24, 0x21	; 33
 19e:	91 e0       	ldi	r25, 0x01	; 1
 1a0:	90 93 99 02 	sts	0x0299, r25
 1a4:	80 93 98 02 	sts	0x0298, r24
		ascii[94] = "^";
 1a8:	83 e2       	ldi	r24, 0x23	; 35
 1aa:	91 e0       	ldi	r25, 0x01	; 1
 1ac:	90 93 9b 02 	sts	0x029B, r25
 1b0:	80 93 9a 02 	sts	0x029A, r24
		ascii[95] = "_";
 1b4:	85 e2       	ldi	r24, 0x25	; 37
 1b6:	91 e0       	ldi	r25, 0x01	; 1
 1b8:	90 93 9d 02 	sts	0x029D, r25
 1bc:	80 93 9c 02 	sts	0x029C, r24
		ascii[96] = "`";
 1c0:	87 e2       	ldi	r24, 0x27	; 39
 1c2:	91 e0       	ldi	r25, 0x01	; 1
 1c4:	90 93 9f 02 	sts	0x029F, r25
 1c8:	80 93 9e 02 	sts	0x029E, r24
		
		ascii[123] = "{";
 1cc:	89 e2       	ldi	r24, 0x29	; 41
 1ce:	91 e0       	ldi	r25, 0x01	; 1
 1d0:	90 93 d5 02 	sts	0x02D5, r25
 1d4:	80 93 d4 02 	sts	0x02D4, r24
		ascii[124] = "|";
 1d8:	8b e2       	ldi	r24, 0x2B	; 43
 1da:	91 e0       	ldi	r25, 0x01	; 1
 1dc:	90 93 d7 02 	sts	0x02D7, r25
 1e0:	80 93 d6 02 	sts	0x02D6, r24
		ascii[125] = "}";
 1e4:	8d e2       	ldi	r24, 0x2D	; 45
 1e6:	91 e0       	ldi	r25, 0x01	; 1
 1e8:	90 93 d9 02 	sts	0x02D9, r25
 1ec:	80 93 d8 02 	sts	0x02D8, r24
		ascii[126] = "~";
 1f0:	8f e2       	ldi	r24, 0x2F	; 47
 1f2:	91 e0       	ldi	r25, 0x01	; 1
 1f4:	90 93 db 02 	sts	0x02DB, r25
 1f8:	80 93 da 02 	sts	0x02DA, r24
		
		ascii[48] = "0"; //Zahlen
 1fc:	81 e3       	ldi	r24, 0x31	; 49
 1fe:	91 e0       	ldi	r25, 0x01	; 1
 200:	90 93 3f 02 	sts	0x023F, r25
 204:	80 93 3e 02 	sts	0x023E, r24
		ascii[49] = "1";
 208:	83 e3       	ldi	r24, 0x33	; 51
 20a:	91 e0       	ldi	r25, 0x01	; 1
 20c:	90 93 41 02 	sts	0x0241, r25
 210:	80 93 40 02 	sts	0x0240, r24
		ascii[50] = "2";
 214:	85 e3       	ldi	r24, 0x35	; 53
 216:	91 e0       	ldi	r25, 0x01	; 1
 218:	90 93 43 02 	sts	0x0243, r25
 21c:	80 93 42 02 	sts	0x0242, r24
		ascii[51] = "3";
 220:	87 e3       	ldi	r24, 0x37	; 55
 222:	91 e0       	ldi	r25, 0x01	; 1
 224:	90 93 45 02 	sts	0x0245, r25
 228:	80 93 44 02 	sts	0x0244, r24
		ascii[52] = "4";
 22c:	89 e3       	ldi	r24, 0x39	; 57
 22e:	91 e0       	ldi	r25, 0x01	; 1
 230:	90 93 47 02 	sts	0x0247, r25
 234:	80 93 46 02 	sts	0x0246, r24
		ascii[53] = "5";
 238:	8b e3       	ldi	r24, 0x3B	; 59
 23a:	91 e0       	ldi	r25, 0x01	; 1
 23c:	90 93 49 02 	sts	0x0249, r25
 240:	80 93 48 02 	sts	0x0248, r24
		ascii[54] = "6";
 244:	8d e3       	ldi	r24, 0x3D	; 61
 246:	91 e0       	ldi	r25, 0x01	; 1
 248:	90 93 4b 02 	sts	0x024B, r25
 24c:	80 93 4a 02 	sts	0x024A, r24
		ascii[55] = "7";
 250:	8f e3       	ldi	r24, 0x3F	; 63
 252:	91 e0       	ldi	r25, 0x01	; 1
 254:	90 93 4d 02 	sts	0x024D, r25
 258:	80 93 4c 02 	sts	0x024C, r24
		ascii[56] = "8";
 25c:	81 e4       	ldi	r24, 0x41	; 65
 25e:	91 e0       	ldi	r25, 0x01	; 1
 260:	90 93 4f 02 	sts	0x024F, r25
 264:	80 93 4e 02 	sts	0x024E, r24
		ascii[57] = "9";
 268:	83 e4       	ldi	r24, 0x43	; 67
 26a:	91 e0       	ldi	r25, 0x01	; 1
 26c:	90 93 51 02 	sts	0x0251, r25
 270:	80 93 50 02 	sts	0x0250, r24
		
		ascii[65] = "A"; //Großbuchstaben
 274:	85 e4       	ldi	r24, 0x45	; 69
 276:	91 e0       	ldi	r25, 0x01	; 1
 278:	90 93 61 02 	sts	0x0261, r25
 27c:	80 93 60 02 	sts	0x0260, r24
		ascii[66] = "B";
 280:	87 e4       	ldi	r24, 0x47	; 71
 282:	91 e0       	ldi	r25, 0x01	; 1
 284:	90 93 63 02 	sts	0x0263, r25
 288:	80 93 62 02 	sts	0x0262, r24
		ascii[67] = "C";
 28c:	89 e4       	ldi	r24, 0x49	; 73
 28e:	91 e0       	ldi	r25, 0x01	; 1
 290:	90 93 65 02 	sts	0x0265, r25
 294:	80 93 64 02 	sts	0x0264, r24
		ascii[68] = "D";
 298:	8b e4       	ldi	r24, 0x4B	; 75
 29a:	91 e0       	ldi	r25, 0x01	; 1
 29c:	90 93 67 02 	sts	0x0267, r25
 2a0:	80 93 66 02 	sts	0x0266, r24
		ascii[69] = "E";
 2a4:	8d e4       	ldi	r24, 0x4D	; 77
 2a6:	91 e0       	ldi	r25, 0x01	; 1
 2a8:	90 93 69 02 	sts	0x0269, r25
 2ac:	80 93 68 02 	sts	0x0268, r24
		ascii[70] = "F";
 2b0:	8f e4       	ldi	r24, 0x4F	; 79
 2b2:	91 e0       	ldi	r25, 0x01	; 1
 2b4:	90 93 6b 02 	sts	0x026B, r25
 2b8:	80 93 6a 02 	sts	0x026A, r24
		ascii[71] = "G";
 2bc:	81 e5       	ldi	r24, 0x51	; 81
 2be:	91 e0       	ldi	r25, 0x01	; 1
 2c0:	90 93 6d 02 	sts	0x026D, r25
 2c4:	80 93 6c 02 	sts	0x026C, r24
		ascii[72] = "H";
 2c8:	83 e5       	ldi	r24, 0x53	; 83
 2ca:	91 e0       	ldi	r25, 0x01	; 1
 2cc:	90 93 6f 02 	sts	0x026F, r25
 2d0:	80 93 6e 02 	sts	0x026E, r24
		ascii[73] = "I";
 2d4:	85 e5       	ldi	r24, 0x55	; 85
 2d6:	91 e0       	ldi	r25, 0x01	; 1
 2d8:	90 93 71 02 	sts	0x0271, r25
 2dc:	80 93 70 02 	sts	0x0270, r24
		ascii[74] = "J";
 2e0:	87 e5       	ldi	r24, 0x57	; 87
 2e2:	91 e0       	ldi	r25, 0x01	; 1
 2e4:	90 93 73 02 	sts	0x0273, r25
 2e8:	80 93 72 02 	sts	0x0272, r24
		ascii[75] = "K";
 2ec:	89 e5       	ldi	r24, 0x59	; 89
 2ee:	91 e0       	ldi	r25, 0x01	; 1
 2f0:	90 93 75 02 	sts	0x0275, r25
 2f4:	80 93 74 02 	sts	0x0274, r24
		ascii[76] = "L";
 2f8:	8b e5       	ldi	r24, 0x5B	; 91
 2fa:	91 e0       	ldi	r25, 0x01	; 1
 2fc:	90 93 77 02 	sts	0x0277, r25
 300:	80 93 76 02 	sts	0x0276, r24
		ascii[77] = "M";
 304:	8d e5       	ldi	r24, 0x5D	; 93
 306:	91 e0       	ldi	r25, 0x01	; 1
 308:	90 93 79 02 	sts	0x0279, r25
 30c:	80 93 78 02 	sts	0x0278, r24
		ascii[78] = "N";
 310:	8f e5       	ldi	r24, 0x5F	; 95
 312:	91 e0       	ldi	r25, 0x01	; 1
 314:	90 93 7b 02 	sts	0x027B, r25
 318:	80 93 7a 02 	sts	0x027A, r24
		ascii[79] = "O";
 31c:	81 e6       	ldi	r24, 0x61	; 97
 31e:	91 e0       	ldi	r25, 0x01	; 1
 320:	90 93 7d 02 	sts	0x027D, r25
 324:	80 93 7c 02 	sts	0x027C, r24
		ascii[80] = "P";
 328:	83 e6       	ldi	r24, 0x63	; 99
 32a:	91 e0       	ldi	r25, 0x01	; 1
 32c:	90 93 7f 02 	sts	0x027F, r25
 330:	80 93 7e 02 	sts	0x027E, r24
		ascii[81] = "Q";
 334:	85 e6       	ldi	r24, 0x65	; 101
 336:	91 e0       	ldi	r25, 0x01	; 1
 338:	90 93 81 02 	sts	0x0281, r25
 33c:	80 93 80 02 	sts	0x0280, r24
		ascii[82] = "R";
 340:	87 e6       	ldi	r24, 0x67	; 103
 342:	91 e0       	ldi	r25, 0x01	; 1
 344:	90 93 83 02 	sts	0x0283, r25
 348:	80 93 82 02 	sts	0x0282, r24
		ascii[83] = "S";
 34c:	89 e6       	ldi	r24, 0x69	; 105
 34e:	91 e0       	ldi	r25, 0x01	; 1
 350:	90 93 85 02 	sts	0x0285, r25
 354:	80 93 84 02 	sts	0x0284, r24
		ascii[84] = "T";
 358:	8b e6       	ldi	r24, 0x6B	; 107
 35a:	91 e0       	ldi	r25, 0x01	; 1
 35c:	90 93 87 02 	sts	0x0287, r25
 360:	80 93 86 02 	sts	0x0286, r24
		ascii[85] = "U";
 364:	8d e6       	ldi	r24, 0x6D	; 109
 366:	91 e0       	ldi	r25, 0x01	; 1
 368:	90 93 89 02 	sts	0x0289, r25
 36c:	80 93 88 02 	sts	0x0288, r24
		ascii[86] = "V";
 370:	8f e6       	ldi	r24, 0x6F	; 111
 372:	91 e0       	ldi	r25, 0x01	; 1
 374:	90 93 8b 02 	sts	0x028B, r25
 378:	80 93 8a 02 	sts	0x028A, r24
		ascii[87] = "W";
 37c:	81 e7       	ldi	r24, 0x71	; 113
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	90 93 8d 02 	sts	0x028D, r25
 384:	80 93 8c 02 	sts	0x028C, r24
		ascii[88] = "X";
 388:	83 e7       	ldi	r24, 0x73	; 115
 38a:	91 e0       	ldi	r25, 0x01	; 1
 38c:	90 93 8f 02 	sts	0x028F, r25
 390:	80 93 8e 02 	sts	0x028E, r24
		ascii[89] = "Y";
 394:	85 e7       	ldi	r24, 0x75	; 117
 396:	91 e0       	ldi	r25, 0x01	; 1
 398:	90 93 91 02 	sts	0x0291, r25
 39c:	80 93 90 02 	sts	0x0290, r24
		ascii[90] = "Z";
 3a0:	87 e7       	ldi	r24, 0x77	; 119
 3a2:	91 e0       	ldi	r25, 0x01	; 1
 3a4:	90 93 93 02 	sts	0x0293, r25
 3a8:	80 93 92 02 	sts	0x0292, r24
		
		ascii[97] = "a"; //Kleinbuchstaben
 3ac:	89 e7       	ldi	r24, 0x79	; 121
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	90 93 a1 02 	sts	0x02A1, r25
 3b4:	80 93 a0 02 	sts	0x02A0, r24
		ascii[98] = "b";
 3b8:	8b e7       	ldi	r24, 0x7B	; 123
 3ba:	91 e0       	ldi	r25, 0x01	; 1
 3bc:	90 93 a3 02 	sts	0x02A3, r25
 3c0:	80 93 a2 02 	sts	0x02A2, r24
		ascii[99] = "c";
 3c4:	8d e7       	ldi	r24, 0x7D	; 125
 3c6:	91 e0       	ldi	r25, 0x01	; 1
 3c8:	90 93 a5 02 	sts	0x02A5, r25
 3cc:	80 93 a4 02 	sts	0x02A4, r24
		ascii[100] = "d";
 3d0:	8f e7       	ldi	r24, 0x7F	; 127
 3d2:	91 e0       	ldi	r25, 0x01	; 1
 3d4:	90 93 a7 02 	sts	0x02A7, r25
 3d8:	80 93 a6 02 	sts	0x02A6, r24
		ascii[101] = "e";
 3dc:	81 e8       	ldi	r24, 0x81	; 129
 3de:	91 e0       	ldi	r25, 0x01	; 1
 3e0:	90 93 a9 02 	sts	0x02A9, r25
 3e4:	80 93 a8 02 	sts	0x02A8, r24
		ascii[102] = "f";
 3e8:	83 e8       	ldi	r24, 0x83	; 131
 3ea:	91 e0       	ldi	r25, 0x01	; 1
 3ec:	90 93 ab 02 	sts	0x02AB, r25
 3f0:	80 93 aa 02 	sts	0x02AA, r24
		ascii[103] = "g";
 3f4:	85 e8       	ldi	r24, 0x85	; 133
 3f6:	91 e0       	ldi	r25, 0x01	; 1
 3f8:	90 93 ad 02 	sts	0x02AD, r25
 3fc:	80 93 ac 02 	sts	0x02AC, r24
		ascii[104] = "h";
 400:	87 e8       	ldi	r24, 0x87	; 135
 402:	91 e0       	ldi	r25, 0x01	; 1
 404:	90 93 af 02 	sts	0x02AF, r25
 408:	80 93 ae 02 	sts	0x02AE, r24
		ascii[105] = "i";
 40c:	89 e8       	ldi	r24, 0x89	; 137
 40e:	91 e0       	ldi	r25, 0x01	; 1
 410:	90 93 b1 02 	sts	0x02B1, r25
 414:	80 93 b0 02 	sts	0x02B0, r24
		ascii[106] = "j";
 418:	8b e8       	ldi	r24, 0x8B	; 139
 41a:	91 e0       	ldi	r25, 0x01	; 1
 41c:	90 93 b3 02 	sts	0x02B3, r25
 420:	80 93 b2 02 	sts	0x02B2, r24
		ascii[107] = "k";
 424:	8d e8       	ldi	r24, 0x8D	; 141
 426:	91 e0       	ldi	r25, 0x01	; 1
 428:	90 93 b5 02 	sts	0x02B5, r25
 42c:	80 93 b4 02 	sts	0x02B4, r24
		ascii[108] = "l";
 430:	8f e8       	ldi	r24, 0x8F	; 143
 432:	91 e0       	ldi	r25, 0x01	; 1
 434:	90 93 b7 02 	sts	0x02B7, r25
 438:	80 93 b6 02 	sts	0x02B6, r24
		ascii[109] = "m";
 43c:	81 e9       	ldi	r24, 0x91	; 145
 43e:	91 e0       	ldi	r25, 0x01	; 1
 440:	90 93 b9 02 	sts	0x02B9, r25
 444:	80 93 b8 02 	sts	0x02B8, r24
		ascii[110] = "n";
 448:	83 e9       	ldi	r24, 0x93	; 147
 44a:	91 e0       	ldi	r25, 0x01	; 1
 44c:	90 93 bb 02 	sts	0x02BB, r25
 450:	80 93 ba 02 	sts	0x02BA, r24
		ascii[111] = "o";
 454:	85 e9       	ldi	r24, 0x95	; 149
 456:	91 e0       	ldi	r25, 0x01	; 1
 458:	90 93 bd 02 	sts	0x02BD, r25
 45c:	80 93 bc 02 	sts	0x02BC, r24
		ascii[112] = "p";
 460:	87 e9       	ldi	r24, 0x97	; 151
 462:	91 e0       	ldi	r25, 0x01	; 1
 464:	90 93 bf 02 	sts	0x02BF, r25
 468:	80 93 be 02 	sts	0x02BE, r24
		ascii[113] = "q";
 46c:	89 e9       	ldi	r24, 0x99	; 153
 46e:	91 e0       	ldi	r25, 0x01	; 1
 470:	90 93 c1 02 	sts	0x02C1, r25
 474:	80 93 c0 02 	sts	0x02C0, r24
		ascii[114] = "r";
 478:	89 eb       	ldi	r24, 0xB9	; 185
 47a:	91 e0       	ldi	r25, 0x01	; 1
 47c:	90 93 c3 02 	sts	0x02C3, r25
 480:	80 93 c2 02 	sts	0x02C2, r24
		ascii[115] = "s";
 484:	8b e9       	ldi	r24, 0x9B	; 155
 486:	91 e0       	ldi	r25, 0x01	; 1
 488:	90 93 c5 02 	sts	0x02C5, r25
 48c:	80 93 c4 02 	sts	0x02C4, r24
		ascii[116] = "t";
 490:	80 ec       	ldi	r24, 0xC0	; 192
 492:	91 e0       	ldi	r25, 0x01	; 1
 494:	90 93 c7 02 	sts	0x02C7, r25
 498:	80 93 c6 02 	sts	0x02C6, r24
		ascii[117] = "u";
 49c:	8d e9       	ldi	r24, 0x9D	; 157
 49e:	91 e0       	ldi	r25, 0x01	; 1
 4a0:	90 93 c9 02 	sts	0x02C9, r25
 4a4:	80 93 c8 02 	sts	0x02C8, r24
		ascii[118] = "v";
 4a8:	8f e9       	ldi	r24, 0x9F	; 159
 4aa:	91 e0       	ldi	r25, 0x01	; 1
 4ac:	90 93 cb 02 	sts	0x02CB, r25
 4b0:	80 93 ca 02 	sts	0x02CA, r24
		ascii[119] = "w";
 4b4:	81 ea       	ldi	r24, 0xA1	; 161
 4b6:	91 e0       	ldi	r25, 0x01	; 1
 4b8:	90 93 cd 02 	sts	0x02CD, r25
 4bc:	80 93 cc 02 	sts	0x02CC, r24
		ascii[120] = "x";
 4c0:	83 ea       	ldi	r24, 0xA3	; 163
 4c2:	91 e0       	ldi	r25, 0x01	; 1
 4c4:	90 93 cf 02 	sts	0x02CF, r25
 4c8:	80 93 ce 02 	sts	0x02CE, r24
		ascii[121] = "y";
 4cc:	85 ea       	ldi	r24, 0xA5	; 165
 4ce:	91 e0       	ldi	r25, 0x01	; 1
 4d0:	90 93 d1 02 	sts	0x02D1, r25
 4d4:	80 93 d0 02 	sts	0x02D0, r24
		ascii[122] = "z";
 4d8:	87 ea       	ldi	r24, 0xA7	; 167
 4da:	91 e0       	ldi	r25, 0x01	; 1
 4dc:	90 93 d3 02 	sts	0x02D3, r25
 4e0:	80 93 d2 02 	sts	0x02D2, r24
 4e4:	08 95       	ret

000004e6 <command>:
		
		
	}
	
void command (uint8_t id) { //Führt Steuerzeichen aus
	if (id == 1 && paused == 0) { //Neue Nachricht
 4e6:	81 30       	cpi	r24, 0x01	; 1
 4e8:	41 f4       	brne	.+16     	; 0x4fa <command+0x14>
 4ea:	80 91 d8 01 	lds	r24, 0x01D8
 4ee:	81 11       	cpse	r24, r1
 4f0:	1d c0       	rjmp	.+58     	; 0x52c <command+0x46>
		set_history("~");
 4f2:	8f e2       	ldi	r24, 0x2F	; 47
 4f4:	91 e0       	ldi	r25, 0x01	; 1
 4f6:	63 d1       	rcall	.+710    	; 0x7be <set_history>
 4f8:	08 95       	ret
	} else if (id == 2 && paused == 0) { //Nachricht ende
 4fa:	82 30       	cpi	r24, 0x02	; 2
 4fc:	31 f4       	brne	.+12     	; 0x50a <command+0x24>
 4fe:	80 91 d8 01 	lds	r24, 0x01D8
 502:	81 11       	cpse	r24, r1
 504:	13 c0       	rjmp	.+38     	; 0x52c <command+0x46>
		index_up();
 506:	50 d1       	rcall	.+672    	; 0x7a8 <index_up>
 508:	08 95       	ret
	} else if (id == 3) { //Breakpoint
 50a:	83 30       	cpi	r24, 0x03	; 3
 50c:	49 f4       	brne	.+18     	; 0x520 <command+0x3a>
		set_history("!Break: ");
 50e:	89 ea       	ldi	r24, 0xA9	; 169
 510:	91 e0       	ldi	r25, 0x01	; 1
 512:	55 d1       	rcall	.+682    	; 0x7be <set_history>
		breaked = 1;
 514:	81 e0       	ldi	r24, 0x01	; 1
 516:	80 93 db 01 	sts	0x01DB, r24
		paused = 0;
 51a:	10 92 d8 01 	sts	0x01D8, r1
 51e:	08 95       	ret
	} else if (id == 4) {
 520:	84 30       	cpi	r24, 0x04	; 4
 522:	21 f4       	brne	.+8      	; 0x52c <command+0x46>
		breaked = 0;
 524:	10 92 db 01 	sts	0x01DB, r1
		paused = 0;
 528:	10 92 d8 01 	sts	0x01D8, r1
 52c:	08 95       	ret

0000052e <process_transfer>:
	}
}

void process_transfer (uint8_t id) { //Verarbeitet empfangende Daten
	if (id < 32) {
 52e:	80 32       	cpi	r24, 0x20	; 32
 530:	10 f4       	brcc	.+4      	; 0x536 <process_transfer+0x8>
		command(id);
 532:	d9 df       	rcall	.-78     	; 0x4e6 <command>
 534:	08 95       	ret
	} else if (paused == 0 || breaked == 1) {
 536:	90 91 d8 01 	lds	r25, 0x01D8
 53a:	99 23       	and	r25, r25
 53c:	21 f0       	breq	.+8      	; 0x546 <process_transfer+0x18>
 53e:	90 91 db 01 	lds	r25, 0x01DB
 542:	91 30       	cpi	r25, 0x01	; 1
 544:	51 f4       	brne	.+20     	; 0x55a <process_transfer+0x2c>
		const char *x = ascii[id];
 546:	e8 2f       	mov	r30, r24
 548:	f0 e0       	ldi	r31, 0x00	; 0
 54a:	ee 0f       	add	r30, r30
 54c:	ff 1f       	adc	r31, r31
 54e:	e2 52       	subi	r30, 0x22	; 34
 550:	fe 4f       	sbci	r31, 0xFE	; 254
		add_history(x);
 552:	80 81       	ld	r24, Z
 554:	91 81       	ldd	r25, Z+1	; 0x01
 556:	42 d1       	rcall	.+644    	; 0x7dc <add_history>
}

void process_transfer (uint8_t id) { //Verarbeitet empfangende Daten
	if (id < 32) {
		command(id);
	} else if (paused == 0 || breaked == 1) {
 558:	08 95       	ret
		const char *x = ascii[id];
		add_history(x);
	} else {
		bit_buffer = 0;
 55a:	10 92 d9 01 	sts	0x01D9, r1
		bit_count = 0;
 55e:	10 92 da 01 	sts	0x01DA, r1
 562:	08 95       	ret

00000564 <reset_communication>:
	}
}

void reset_communication(void) {
	bit_buffer = 0; //Setzt Kommunikationsvariablen zurück
 564:	10 92 d9 01 	sts	0x01D9, r1
	bit_count = 0;
 568:	10 92 da 01 	sts	0x01DA, r1
	paused = 0;
 56c:	10 92 d8 01 	sts	0x01D8, r1
	breaked = 0;
 570:	10 92 db 01 	sts	0x01DB, r1
	DDRD |= (1<<3); //Pin Eingänge wiederherstellen
 574:	8b 9a       	sbi	0x11, 3	; 17
	PORTD &= ~(1<<3);
 576:	93 98       	cbi	0x12, 3	; 18
	DDRD &= ~(1<<3);
 578:	8b 98       	cbi	0x11, 3	; 17
	PORTD|=(1<<3);
 57a:	93 9a       	sbi	0x12, 3	; 18
 57c:	08 95       	ret

0000057e <breakpoint_continue>:
}

void breakpoint_continue(void) { //Sendet den Impuls zum Fortfahren und dreht die Datenleitung anschließend wieder um
	if (breaked == 1) {
 57e:	80 91 db 01 	lds	r24, 0x01DB
 582:	81 30       	cpi	r24, 0x01	; 1
 584:	71 f4       	brne	.+28     	; 0x5a2 <breakpoint_continue+0x24>
		DDRD |= (1<<3);
 586:	8b 9a       	sbi	0x11, 3	; 17
		PORTD &= ~(1<<3);
 588:	93 98       	cbi	0x12, 3	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 58a:	2f ef       	ldi	r18, 0xFF	; 255
 58c:	80 e7       	ldi	r24, 0x70	; 112
 58e:	92 e0       	ldi	r25, 0x02	; 2
 590:	21 50       	subi	r18, 0x01	; 1
 592:	80 40       	sbci	r24, 0x00	; 0
 594:	90 40       	sbci	r25, 0x00	; 0
 596:	e1 f7       	brne	.-8      	; 0x590 <breakpoint_continue+0x12>
 598:	00 c0       	rjmp	.+0      	; 0x59a <breakpoint_continue+0x1c>
 59a:	00 00       	nop
		_delay_ms(100);
		DDRD &= ~(1<<3);
 59c:	8b 98       	cbi	0x11, 3	; 17
		PORTD|=(1<<3);
 59e:	93 9a       	sbi	0x12, 3	; 18
		reset_communication();
 5a0:	e1 df       	rcall	.-62     	; 0x564 <reset_communication>
 5a2:	08 95       	ret

000005a4 <is_breaked>:
	}
}

unsigned char is_breaked(void) {
	return (breaked);
}
 5a4:	80 91 db 01 	lds	r24, 0x01DB
 5a8:	08 95       	ret

000005aa <pause>:

void pause (unsigned char set) {
	if (set == 1 || set == 0) {
 5aa:	82 30       	cpi	r24, 0x02	; 2
 5ac:	10 f4       	brcc	.+4      	; 0x5b2 <pause+0x8>
		paused = set;
 5ae:	80 93 d8 01 	sts	0x01D8, r24
 5b2:	08 95       	ret

000005b4 <is_paused>:
	}
}

unsigned char is_paused (void) {
	return (paused);
}
 5b4:	80 91 d8 01 	lds	r24, 0x01D8
 5b8:	08 95       	ret

000005ba <__vector_1>:

ISR(INT0_vect) { //Interrupt bei Datentakt
 5ba:	1f 92       	push	r1
 5bc:	0f 92       	push	r0
 5be:	0f b6       	in	r0, 0x3f	; 63
 5c0:	0f 92       	push	r0
 5c2:	11 24       	eor	r1, r1
 5c4:	2f 93       	push	r18
 5c6:	3f 93       	push	r19
 5c8:	4f 93       	push	r20
 5ca:	5f 93       	push	r21
 5cc:	6f 93       	push	r22
 5ce:	7f 93       	push	r23
 5d0:	8f 93       	push	r24
 5d2:	9f 93       	push	r25
 5d4:	af 93       	push	r26
 5d6:	bf 93       	push	r27
 5d8:	ef 93       	push	r30
 5da:	ff 93       	push	r31
	if (PIND & (1<<3)) { //Logisch 1, Addition des Bit Values
 5dc:	83 9b       	sbis	0x10, 3	; 16
 5de:	0b c0       	rjmp	.+22     	; 0x5f6 <__vector_1+0x3c>
		bit_buffer = bit_buffer + bit_value[bit_count];
 5e0:	e0 91 da 01 	lds	r30, 0x01DA
 5e4:	f0 e0       	ldi	r31, 0x00	; 0
 5e6:	e0 5a       	subi	r30, 0xA0	; 160
 5e8:	ff 4f       	sbci	r31, 0xFF	; 255
 5ea:	90 91 d9 01 	lds	r25, 0x01D9
 5ee:	80 81       	ld	r24, Z
 5f0:	89 0f       	add	r24, r25
 5f2:	80 93 d9 01 	sts	0x01D9, r24
	}
		
	bit_count += 1;
 5f6:	80 91 da 01 	lds	r24, 0x01DA
 5fa:	8f 5f       	subi	r24, 0xFF	; 255
 5fc:	80 93 da 01 	sts	0x01DA, r24

	if (bit_count == 7) {
 600:	87 30       	cpi	r24, 0x07	; 7
 602:	39 f4       	brne	.+14     	; 0x612 <__vector_1+0x58>
		process_transfer(bit_buffer);
 604:	80 91 d9 01 	lds	r24, 0x01D9
 608:	92 df       	rcall	.-220    	; 0x52e <process_transfer>
		bit_count = 0;
 60a:	10 92 da 01 	sts	0x01DA, r1
		bit_buffer = 0;
 60e:	10 92 d9 01 	sts	0x01D9, r1
	}
 612:	ff 91       	pop	r31
 614:	ef 91       	pop	r30
 616:	bf 91       	pop	r27
 618:	af 91       	pop	r26
 61a:	9f 91       	pop	r25
 61c:	8f 91       	pop	r24
 61e:	7f 91       	pop	r23
 620:	6f 91       	pop	r22
 622:	5f 91       	pop	r21
 624:	4f 91       	pop	r20
 626:	3f 91       	pop	r19
 628:	2f 91       	pop	r18
 62a:	0f 90       	pop	r0
 62c:	0f be       	out	0x3f, r0	; 63
 62e:	0f 90       	pop	r0
 630:	1f 90       	pop	r1
 632:	18 95       	reti

00000634 <main>:

char lcd_buffer[100] = "";

int main(void) {
	//Ausgänge
	DDRB |= (1<<5); //LED Grün
 634:	bd 9a       	sbi	0x17, 5	; 23
	DDRB |= (1<<4); //LED Gelb
 636:	bc 9a       	sbi	0x17, 4	; 23
	
	//Eingänge
	DDRD &= ~(1<<5); //Löschen, Rot
 638:	8d 98       	cbi	0x11, 5	; 17
	PORTD|=(1<<5);
 63a:	95 9a       	sbi	0x12, 5	; 18
	
	DDRD &= ~(1<<6); //Hoch scrollen, Grün
 63c:	8e 98       	cbi	0x11, 6	; 17
	PORTD|=(1<<6);
 63e:	96 9a       	sbi	0x12, 6	; 18
	
	DDRD &= ~(1<<7); //Runter scrollen, Blau
 640:	8f 98       	cbi	0x11, 7	; 17
	PORTD|=(1<<7);
 642:	97 9a       	sbi	0x12, 7	; 18
	
	DDRB &= ~(1<<0); //Pause, Violett
 644:	b8 98       	cbi	0x17, 0	; 23
	PORTB|=(1<<0);
 646:	c0 9a       	sbi	0x18, 0	; 24
	
	//LCD Initialisieren
	lcd_init();
 648:	2d d1       	rcall	.+602    	; 0x8a4 <lcd_init>
	lcd_clear();
 64a:	23 d1       	rcall	.+582    	; 0x892 <lcd_clear>
	lcd_setcursor(6, 2);
 64c:	62 e0       	ldi	r22, 0x02	; 2
 64e:	86 e0       	ldi	r24, 0x06	; 6
 650:	5b d1       	rcall	.+694    	; 0x908 <lcd_setcursor>
	
	lcd_string("Debugger");
 652:	82 eb       	ldi	r24, 0xB2	; 178
 654:	91 e0       	ldi	r25, 0x01	; 1
 656:	6c d1       	rcall	.+728    	; 0x930 <lcd_string>
	lcd_setcursor(7, 3);
 658:	63 e0       	ldi	r22, 0x03	; 3
 65a:	87 e0       	ldi	r24, 0x07	; 7
 65c:	55 d1       	rcall	.+682    	; 0x908 <lcd_setcursor>
	lcd_string("bereit");
 65e:	8b eb       	ldi	r24, 0xBB	; 187
 660:	91 e0       	ldi	r25, 0x01	; 1
 662:	66 d1       	rcall	.+716    	; 0x930 <lcd_string>
	unsigned char scroll_up_released = 1;
	unsigned char scroll_down_released = 1;
	unsigned char pause_released = 1;
	
	
	dict_initialization(); //Angepasste ASCII Zeichentabelle laden
 664:	07 dd       	rcall	.-1522   	; 0x74 <dict_initialization>
	init_communication();
 666:	fb dc       	rcall	.-1546   	; 0x5e <init_communication>
	sei(); //Initialisierung abgeschlossen, Interrupts aktivieren
 668:	78 94       	sei
	signed char history_index_cache = 0;
	unsigned char scroll_offset = 0;
	
	unsigned char scroll_up_released = 1;
	unsigned char scroll_down_released = 1;
	unsigned char pause_released = 1;
 66a:	ff 24       	eor	r15, r15
 66c:	f3 94       	inc	r15
	unsigned char lcd_zeile = 0;
	signed char history_index_cache = 0;
	unsigned char scroll_offset = 0;
	
	unsigned char scroll_up_released = 1;
	unsigned char scroll_down_released = 1;
 66e:	dd 24       	eor	r13, r13
 670:	d3 94       	inc	r13
	//Variablen Deklaration
	unsigned char lcd_zeile = 0;
	signed char history_index_cache = 0;
	unsigned char scroll_offset = 0;
	
	unsigned char scroll_up_released = 1;
 672:	ee 24       	eor	r14, r14
 674:	e3 94       	inc	r14
	lcd_string("bereit");
	
	//Variablen Deklaration
	unsigned char lcd_zeile = 0;
	signed char history_index_cache = 0;
	unsigned char scroll_offset = 0;
 676:	00 e0       	ldi	r16, 0x00	; 0
	sei(); //Initialisierung abgeschlossen, Interrupts aktivieren
	
	while(1) {
		//Display Generator
		if (is_breaked() == 1 && scroll_offset > 0) {
			scroll_offset = 0;
 678:	10 e0       	ldi	r17, 0x00	; 0
			if (scroll_offset < 3) { //TODO: Wert anpassen
				scroll_offset++;
				update_lcd();
			}
		} else if ((PIND & (1<<6)) && scroll_up_released == 0) {
			scroll_up_released = 1;
 67a:	cc 24       	eor	r12, r12
 67c:	c3 94       	inc	r12
	init_communication();
	sei(); //Initialisierung abgeschlossen, Interrupts aktivieren
	
	while(1) {
		//Display Generator
		if (is_breaked() == 1 && scroll_offset > 0) {
 67e:	92 df       	rcall	.-220    	; 0x5a4 <is_breaked>
 680:	81 30       	cpi	r24, 0x01	; 1
 682:	21 f4       	brne	.+8      	; 0x68c <main+0x58>
 684:	00 23       	and	r16, r16
 686:	11 f0       	breq	.+4      	; 0x68c <main+0x58>
			scroll_offset = 0;
			update_lcd();
 688:	c5 d0       	rcall	.+394    	; 0x814 <update_lcd>
	sei(); //Initialisierung abgeschlossen, Interrupts aktivieren
	
	while(1) {
		//Display Generator
		if (is_breaked() == 1 && scroll_offset > 0) {
			scroll_offset = 0;
 68a:	01 2f       	mov	r16, r17
			update_lcd();
		}
		
		history_index_cache = get_history_index() - scroll_offset - 4;
 68c:	a4 d0       	rcall	.+328    	; 0x7d6 <get_history_index>
 68e:	80 1b       	sub	r24, r16
 690:	dc ef       	ldi	r29, 0xFC	; 252
 692:	d8 0f       	add	r29, r24
		
		if (history_index_cache < 0) {
 694:	0a f0       	brmi	.+2      	; 0x698 <main+0x64>
 696:	86 c0       	rjmp	.+268    	; 0x7a4 <main+0x170>
			history_index_cache += 7; //TODO: ++
 698:	d3 e0       	ldi	r29, 0x03	; 3
 69a:	d8 0f       	add	r29, r24
 69c:	83 c0       	rjmp	.+262    	; 0x7a4 <main+0x170>
		}
		
		while (lcd_zeile < 4 && history_modified() == 1) {
				lcd_setcursor(0, lcd_zeile + 1);
 69e:	cf 5f       	subi	r28, 0xFF	; 255
 6a0:	6c 2f       	mov	r22, r28
 6a2:	81 2f       	mov	r24, r17
 6a4:	31 d1       	rcall	.+610    	; 0x908 <lcd_setcursor>
				lcd_string("                    ");
 6a6:	82 ec       	ldi	r24, 0xC2	; 194
 6a8:	91 e0       	ldi	r25, 0x01	; 1
 6aa:	42 d1       	rcall	.+644    	; 0x930 <lcd_string>
				lcd_setcursor(0, lcd_zeile + 1);
 6ac:	6c 2f       	mov	r22, r28
 6ae:	81 2f       	mov	r24, r17
 6b0:	2b d1       	rcall	.+598    	; 0x908 <lcd_setcursor>
				lcd_string(get_history(history_index_cache));
 6b2:	8d 2f       	mov	r24, r29
 6b4:	a2 d0       	rcall	.+324    	; 0x7fa <get_history>
 6b6:	90 e0       	ldi	r25, 0x00	; 0
 6b8:	3b d1       	rcall	.+630    	; 0x930 <lcd_string>
				
			lcd_zeile += 1;
			
			if (history_index_cache < 6) {
 6ba:	d6 30       	cpi	r29, 0x06	; 6
 6bc:	14 f4       	brge	.+4      	; 0x6c2 <main+0x8e>
				history_index_cache++;
 6be:	df 5f       	subi	r29, 0xFF	; 255
 6c0:	01 c0       	rjmp	.+2      	; 0x6c4 <main+0x90>
			} else {
				history_index_cache = 0;
 6c2:	d1 2f       	mov	r29, r17
		
		if (history_index_cache < 0) {
			history_index_cache += 7; //TODO: ++
		}
		
		while (lcd_zeile < 4 && history_modified() == 1) {
 6c4:	c4 30       	cpi	r28, 0x04	; 4
 6c6:	19 f0       	breq	.+6      	; 0x6ce <main+0x9a>
 6c8:	9f d0       	rcall	.+318    	; 0x808 <history_modified>
 6ca:	81 30       	cpi	r24, 0x01	; 1
 6cc:	41 f3       	breq	.-48     	; 0x69e <main+0x6a>
			} else {
				history_index_cache = 0;
			}
			
		}
		history_refreshed();
 6ce:	9f d0       	rcall	.+318    	; 0x80e <history_refreshed>
		lcd_zeile = 0;
		
		//Buttons
		if (!(PIND & (1<<5))) { //Nachrichten löschen
 6d0:	85 99       	sbic	0x10, 5	; 16
 6d2:	03 c0       	rjmp	.+6      	; 0x6da <main+0xa6>
			history_clear();
 6d4:	a3 d0       	rcall	.+326    	; 0x81c <history_clear>
			breakpoint_continue();
 6d6:	53 df       	rcall	.-346    	; 0x57e <breakpoint_continue>
			reset_communication();
 6d8:	45 df       	rcall	.-374    	; 0x564 <reset_communication>
		}
		
		if (!(PIND & (1<<6)) && scroll_up_released == 1) { //Hoch scrollen
 6da:	86 99       	sbic	0x10, 6	; 16
 6dc:	0b c0       	rjmp	.+22     	; 0x6f4 <main+0xc0>
 6de:	21 e0       	ldi	r18, 0x01	; 1
 6e0:	e2 12       	cpse	r14, r18
 6e2:	08 c0       	rjmp	.+16     	; 0x6f4 <main+0xc0>
			scroll_up_released = 0;
			pause(1);
 6e4:	8c 2d       	mov	r24, r12
 6e6:	61 df       	rcall	.-318    	; 0x5aa <pause>
			if (scroll_offset < 3) { //TODO: Wert anpassen
 6e8:	03 30       	cpi	r16, 0x03	; 3
 6ea:	48 f4       	brcc	.+18     	; 0x6fe <main+0xca>
				scroll_offset++;
 6ec:	0f 5f       	subi	r16, 0xFF	; 255
				update_lcd();
 6ee:	92 d0       	rcall	.+292    	; 0x814 <update_lcd>
			breakpoint_continue();
			reset_communication();
		}
		
		if (!(PIND & (1<<6)) && scroll_up_released == 1) { //Hoch scrollen
			scroll_up_released = 0;
 6f0:	e1 2e       	mov	r14, r17
 6f2:	08 c0       	rjmp	.+16     	; 0x704 <main+0xd0>
			pause(1);
			if (scroll_offset < 3) { //TODO: Wert anpassen
				scroll_offset++;
				update_lcd();
			}
		} else if ((PIND & (1<<6)) && scroll_up_released == 0) {
 6f4:	86 9b       	sbis	0x10, 6	; 16
 6f6:	06 c0       	rjmp	.+12     	; 0x704 <main+0xd0>
 6f8:	ee 20       	and	r14, r14
 6fa:	19 f0       	breq	.+6      	; 0x702 <main+0xce>
 6fc:	03 c0       	rjmp	.+6      	; 0x704 <main+0xd0>
			breakpoint_continue();
			reset_communication();
		}
		
		if (!(PIND & (1<<6)) && scroll_up_released == 1) { //Hoch scrollen
			scroll_up_released = 0;
 6fe:	e1 2e       	mov	r14, r17
 700:	01 c0       	rjmp	.+2      	; 0x704 <main+0xd0>
			if (scroll_offset < 3) { //TODO: Wert anpassen
				scroll_offset++;
				update_lcd();
			}
		} else if ((PIND & (1<<6)) && scroll_up_released == 0) {
			scroll_up_released = 1;
 702:	ec 2c       	mov	r14, r12
		}
		
		if (!(PIND & (1<<7)) && scroll_down_released == 1) { //Runter scrollen
 704:	87 99       	sbic	0x10, 7	; 16
 706:	0d c0       	rjmp	.+26     	; 0x722 <main+0xee>
 708:	81 e0       	ldi	r24, 0x01	; 1
 70a:	d8 12       	cpse	r13, r24
 70c:	0a c0       	rjmp	.+20     	; 0x722 <main+0xee>
			scroll_down_released = 0;
			if (scroll_offset > 0) { //TODO: Wert anpassen
 70e:	00 23       	and	r16, r16
 710:	21 f0       	breq	.+8      	; 0x71a <main+0xe6>
				scroll_offset--;
 712:	01 50       	subi	r16, 0x01	; 1
				update_lcd();
 714:	7f d0       	rcall	.+254    	; 0x814 <update_lcd>
		} else if ((PIND & (1<<6)) && scroll_up_released == 0) {
			scroll_up_released = 1;
		}
		
		if (!(PIND & (1<<7)) && scroll_down_released == 1) { //Runter scrollen
			scroll_down_released = 0;
 716:	d1 2e       	mov	r13, r17
 718:	09 c0       	rjmp	.+18     	; 0x72c <main+0xf8>
			if (scroll_offset > 0) { //TODO: Wert anpassen
				scroll_offset--;
				update_lcd();
			} else {
				pause(0);
 71a:	81 2f       	mov	r24, r17
 71c:	46 df       	rcall	.-372    	; 0x5aa <pause>
		} else if ((PIND & (1<<6)) && scroll_up_released == 0) {
			scroll_up_released = 1;
		}
		
		if (!(PIND & (1<<7)) && scroll_down_released == 1) { //Runter scrollen
			scroll_down_released = 0;
 71e:	d1 2e       	mov	r13, r17
 720:	05 c0       	rjmp	.+10     	; 0x72c <main+0xf8>
				scroll_offset--;
				update_lcd();
			} else {
				pause(0);
			}
		} else if ((PIND & (1<<7)) && scroll_down_released == 0) {
 722:	87 9b       	sbis	0x10, 7	; 16
 724:	03 c0       	rjmp	.+6      	; 0x72c <main+0xf8>
 726:	d1 10       	cpse	r13, r1
 728:	01 c0       	rjmp	.+2      	; 0x72c <main+0xf8>
			scroll_down_released = 1;
 72a:	dc 2c       	mov	r13, r12
		}
		
		if (!(PINB & (1<<0)) && pause_released == 1) { //Pause
 72c:	b0 99       	sbic	0x16, 0	; 22
 72e:	13 c0       	rjmp	.+38     	; 0x756 <main+0x122>
 730:	91 e0       	ldi	r25, 0x01	; 1
 732:	f9 12       	cpse	r15, r25
 734:	10 c0       	rjmp	.+32     	; 0x756 <main+0x122>
			pause_released = 0;
			
			if (is_paused() == 0) { //Wenn Pausiert
 736:	3e df       	rcall	.-388    	; 0x5b4 <is_paused>
 738:	81 11       	cpse	r24, r1
 73a:	03 c0       	rjmp	.+6      	; 0x742 <main+0x10e>
				pause(1);
 73c:	8c 2d       	mov	r24, r12
 73e:	35 df       	rcall	.-406    	; 0x5aa <pause>
 740:	04 c0       	rjmp	.+8      	; 0x74a <main+0x116>
			} else {
				pause(0);
 742:	81 2f       	mov	r24, r17
 744:	32 df       	rcall	.-412    	; 0x5aa <pause>
				scroll_offset = 0; //Scrolling mit beenden der Pause zurücksetzen
				update_lcd();
 746:	66 d0       	rcall	.+204    	; 0x814 <update_lcd>
			
			if (is_paused() == 0) { //Wenn Pausiert
				pause(1);
			} else {
				pause(0);
				scroll_offset = 0; //Scrolling mit beenden der Pause zurücksetzen
 748:	01 2f       	mov	r16, r17
				update_lcd();
			}
			
			if (is_breaked() == 1) { //Wenn warten auf Breakpoint
 74a:	2c df       	rcall	.-424    	; 0x5a4 <is_breaked>
 74c:	81 30       	cpi	r24, 0x01	; 1
 74e:	41 f4       	brne	.+16     	; 0x760 <main+0x12c>
				breakpoint_continue();
 750:	16 df       	rcall	.-468    	; 0x57e <breakpoint_continue>
		} else if ((PIND & (1<<7)) && scroll_down_released == 0) {
			scroll_down_released = 1;
		}
		
		if (!(PINB & (1<<0)) && pause_released == 1) { //Pause
			pause_released = 0;
 752:	f1 2e       	mov	r15, r17
 754:	08 c0       	rjmp	.+16     	; 0x766 <main+0x132>
			
			if (is_breaked() == 1) { //Wenn warten auf Breakpoint
				breakpoint_continue();
			}
			
		} else if ((PINB & (1<<0)) && pause_released == 0) {
 756:	b0 9b       	sbis	0x16, 0	; 22
 758:	06 c0       	rjmp	.+12     	; 0x766 <main+0x132>
 75a:	ff 20       	and	r15, r15
 75c:	19 f0       	breq	.+6      	; 0x764 <main+0x130>
 75e:	03 c0       	rjmp	.+6      	; 0x766 <main+0x132>
		} else if ((PIND & (1<<7)) && scroll_down_released == 0) {
			scroll_down_released = 1;
		}
		
		if (!(PINB & (1<<0)) && pause_released == 1) { //Pause
			pause_released = 0;
 760:	f1 2e       	mov	r15, r17
 762:	01 c0       	rjmp	.+2      	; 0x766 <main+0x132>
			if (is_breaked() == 1) { //Wenn warten auf Breakpoint
				breakpoint_continue();
			}
			
		} else if ((PINB & (1<<0)) && pause_released == 0) {
			pause_released = 1;
 764:	fc 2c       	mov	r15, r12
		}
		
		//Status LEDs
		if (is_paused() == 1 || is_breaked() == 1) { //Paused & Breaked
 766:	26 df       	rcall	.-436    	; 0x5b4 <is_paused>
 768:	81 30       	cpi	r24, 0x01	; 1
 76a:	19 f0       	breq	.+6      	; 0x772 <main+0x13e>
 76c:	1b df       	rcall	.-458    	; 0x5a4 <is_breaked>
 76e:	81 30       	cpi	r24, 0x01	; 1
 770:	11 f4       	brne	.+4      	; 0x776 <main+0x142>
			PORTB|=(1<<5);
 772:	c5 9a       	sbi	0x18, 5	; 24
 774:	01 c0       	rjmp	.+2      	; 0x778 <main+0x144>
		} else {
			PORTB&=~(1<<5);
 776:	c5 98       	cbi	0x18, 5	; 24
		}
		
		if (scroll_offset > 0) { //Scrolling
 778:	00 23       	and	r16, r16
 77a:	11 f0       	breq	.+4      	; 0x780 <main+0x14c>
			PORTB|=(1<<4);
 77c:	c4 9a       	sbi	0x18, 4	; 24
 77e:	01 c0       	rjmp	.+2      	; 0x782 <main+0x14e>
		} else {
			PORTB&=~(1<<4);
 780:	c4 98       	cbi	0x18, 4	; 24
		}
		
		
		if (is_breaked() && (PIND & (1<<2))) { //Während umgekehrte Kommunikation läuft, prüfen, ob Debugger im Empfangsmodus ist
 782:	10 df       	rcall	.-480    	; 0x5a4 <is_breaked>
 784:	88 23       	and	r24, r24
 786:	21 f0       	breq	.+8      	; 0x790 <main+0x15c>
 788:	82 9b       	sbis	0x10, 2	; 16
 78a:	02 c0       	rjmp	.+4      	; 0x790 <main+0x15c>
			history_clear();
 78c:	47 d0       	rcall	.+142    	; 0x81c <history_clear>
			reset_communication();
 78e:	ea de       	rcall	.-556    	; 0x564 <reset_communication>
 790:	2f e7       	ldi	r18, 0x7F	; 127
 792:	88 e3       	ldi	r24, 0x38	; 56
 794:	91 e0       	ldi	r25, 0x01	; 1
 796:	21 50       	subi	r18, 0x01	; 1
 798:	80 40       	sbci	r24, 0x00	; 0
 79a:	90 40       	sbci	r25, 0x00	; 0
 79c:	e1 f7       	brne	.-8      	; 0x796 <main+0x162>
 79e:	00 c0       	rjmp	.+0      	; 0x7a0 <main+0x16c>
 7a0:	00 00       	nop
 7a2:	6d cf       	rjmp	.-294    	; 0x67e <main+0x4a>
			lcd_zeile += 1;
			
			if (history_index_cache < 6) {
				history_index_cache++;
			} else {
				history_index_cache = 0;
 7a4:	c1 2f       	mov	r28, r17
 7a6:	90 cf       	rjmp	.-224    	; 0x6c8 <main+0x94>

000007a8 <index_up>:
	history_index = new_index;
}

void index_up (void) {
	
	if (history_index < 6) {
 7a8:	80 91 dd 01 	lds	r24, 0x01DD
 7ac:	86 30       	cpi	r24, 0x06	; 6
 7ae:	20 f4       	brcc	.+8      	; 0x7b8 <index_up+0x10>
		history_index += 1; //TODO: ++
 7b0:	8f 5f       	subi	r24, 0xFF	; 255
 7b2:	80 93 dd 01 	sts	0x01DD, r24
 7b6:	08 95       	ret
	} else {
		history_index = 0;
 7b8:	10 92 dd 01 	sts	0x01DD, r1
 7bc:	08 95       	ret

000007be <set_history>:
		history_index = 6;
	}
}

void set_history (const char *text) { //TODO: rename to set_history_index
	strcpy(history[history_index], text);
 7be:	20 91 dd 01 	lds	r18, 0x01DD
 7c2:	44 e1       	ldi	r20, 0x14	; 20
 7c4:	24 9f       	mul	r18, r20
 7c6:	90 01       	movw	r18, r0
 7c8:	11 24       	eor	r1, r1
 7ca:	bc 01       	movw	r22, r24
 7cc:	c9 01       	movw	r24, r18
 7ce:	89 59       	subi	r24, 0x99	; 153
 7d0:	9f 4f       	sbci	r25, 0xFF	; 255
 7d2:	c7 d0       	rcall	.+398    	; 0x962 <strcpy>
 7d4:	08 95       	ret

000007d6 <get_history_index>:
}

unsigned char get_history_index(void) {
	return (history_index);
}
 7d6:	80 91 dd 01 	lds	r24, 0x01DD
 7da:	08 95       	ret

000007dc <add_history>:

void add_history (const char *text) {
	strcat(history[history_index], text);
 7dc:	20 91 dd 01 	lds	r18, 0x01DD
 7e0:	44 e1       	ldi	r20, 0x14	; 20
 7e2:	24 9f       	mul	r18, r20
 7e4:	90 01       	movw	r18, r0
 7e6:	11 24       	eor	r1, r1
 7e8:	bc 01       	movw	r22, r24
 7ea:	c9 01       	movw	r24, r18
 7ec:	89 59       	subi	r24, 0x99	; 153
 7ee:	9f 4f       	sbci	r25, 0xFF	; 255
 7f0:	ad d0       	rcall	.+346    	; 0x94c <strcat>
	modified = 1;
 7f2:	81 e0       	ldi	r24, 0x01	; 1
 7f4:	80 93 dc 01 	sts	0x01DC, r24
 7f8:	08 95       	ret

000007fa <get_history>:
}

char get_history (unsigned char index) {
	return (history[index]);
 7fa:	24 e1       	ldi	r18, 0x14	; 20
 7fc:	82 9f       	mul	r24, r18
 7fe:	c0 01       	movw	r24, r0
 800:	11 24       	eor	r1, r1
 802:	89 59       	subi	r24, 0x99	; 153
 804:	9f 4f       	sbci	r25, 0xFF	; 255
}
 806:	08 95       	ret

00000808 <history_modified>:

unsigned char history_modified (void) {
	return (modified);
}
 808:	80 91 dc 01 	lds	r24, 0x01DC
 80c:	08 95       	ret

0000080e <history_refreshed>:

void history_refreshed (void) {
	modified = 0;
 80e:	10 92 dc 01 	sts	0x01DC, r1
 812:	08 95       	ret

00000814 <update_lcd>:
}

void update_lcd(void) {
	modified = 1;
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	80 93 dc 01 	sts	0x01DC, r24
 81a:	08 95       	ret

0000081c <history_clear>:
}

void history_clear (void) {
 81c:	e7 e6       	ldi	r30, 0x67	; 103
 81e:	f0 e0       	ldi	r31, 0x00	; 0
 820:	83 ef       	ldi	r24, 0xF3	; 243
 822:	90 e0       	ldi	r25, 0x00	; 0
	history_index = 0;
	while (history_index < 7) {
		strcpy(history[history_index], "");
 824:	10 82       	st	Z, r1
 826:	74 96       	adiw	r30, 0x14	; 20
	modified = 1;
}

void history_clear (void) {
	history_index = 0;
	while (history_index < 7) {
 828:	e8 17       	cp	r30, r24
 82a:	f9 07       	cpc	r31, r25
 82c:	d9 f7       	brne	.-10     	; 0x824 <history_clear+0x8>
		strcpy(history[history_index], "");
		history_index += 1;
	}
	modified = 1;
 82e:	81 e0       	ldi	r24, 0x01	; 1
 830:	80 93 dc 01 	sts	0x01DC, r24
	
	history_index = 0;
 834:	10 92 dd 01 	sts	0x01DD, r1
 838:	08 95       	ret

0000083a <lcd_enable>:

////////////////////////////////////////////////////////////////////////////////
// Erzeugt einen Enable-Puls
static void lcd_enable( void )
{
	LCD_PORT |= (1<<LCD_EN);     // Enable auf 1 setzen
 83a:	ad 9a       	sbi	0x15, 5	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 83c:	85 e3       	ldi	r24, 0x35	; 53
 83e:	8a 95       	dec	r24
 840:	f1 f7       	brne	.-4      	; 0x83e <lcd_enable+0x4>
 842:	00 00       	nop
	_delay_us( LCD_ENABLE_US );  // kurze Pause
	LCD_PORT &= ~(1<<LCD_EN);    // Enable auf 0 setzen
 844:	ad 98       	cbi	0x15, 5	; 21
 846:	08 95       	ret

00000848 <lcd_out>:
// Sendet eine 4-bit Ausgabeoperation an das LCD
static void lcd_out( uint8_t data )
{
	data &= 0xF0;                       // obere 4 Bit maskieren
	
	LCD_PORT &= ~(0xF0>>(4-LCD_DB));    // Maske löschen
 848:	95 b3       	in	r25, 0x15	; 21
 84a:	90 7f       	andi	r25, 0xF0	; 240
 84c:	95 bb       	out	0x15, r25	; 21
	LCD_PORT |= (data>>(4-LCD_DB));     // Bits setzen
 84e:	95 b3       	in	r25, 0x15	; 21
 850:	82 95       	swap	r24
 852:	8f 70       	andi	r24, 0x0F	; 15
 854:	98 2b       	or	r25, r24
 856:	95 bb       	out	0x15, r25	; 21
	lcd_enable();
 858:	f0 df       	rcall	.-32     	; 0x83a <lcd_enable>
 85a:	08 95       	ret

0000085c <lcd_data>:
}

////////////////////////////////////////////////////////////////////////////////
// Sendet ein Datenbyte an das LCD
void lcd_data( uint8_t data )
{
 85c:	cf 93       	push	r28
 85e:	c8 2f       	mov	r28, r24
	LCD_PORT |= (1<<LCD_RS);    // RS auf 1 setzen
 860:	ac 9a       	sbi	0x15, 4	; 21
	
	lcd_out( data );            // zuerst die oberen,
 862:	f2 df       	rcall	.-28     	; 0x848 <lcd_out>
	lcd_out( data<<4 );         // dann die unteren 4 Bit senden
 864:	8c 2f       	mov	r24, r28
 866:	82 95       	swap	r24
 868:	80 7f       	andi	r24, 0xF0	; 240
 86a:	ee df       	rcall	.-36     	; 0x848 <lcd_out>
 86c:	8a e7       	ldi	r24, 0x7A	; 122
 86e:	8a 95       	dec	r24
 870:	f1 f7       	brne	.-4      	; 0x86e <lcd_data+0x12>
 872:	00 c0       	rjmp	.+0      	; 0x874 <lcd_data+0x18>
	
	_delay_us( LCD_WRITEDATA_US );
}
 874:	cf 91       	pop	r28
 876:	08 95       	ret

00000878 <lcd_command>:

////////////////////////////////////////////////////////////////////////////////
// Sendet einen Befehl an das LCD
void lcd_command( uint8_t data )
{
 878:	cf 93       	push	r28
 87a:	c8 2f       	mov	r28, r24
	LCD_PORT &= ~(1<<LCD_RS);    // RS auf 0 setzen
 87c:	ac 98       	cbi	0x15, 4	; 21
	
	lcd_out( data );             // zuerst die oberen,
 87e:	e4 df       	rcall	.-56     	; 0x848 <lcd_out>
	lcd_out( data<<4 );           // dann die unteren 4 Bit senden
 880:	8c 2f       	mov	r24, r28
 882:	82 95       	swap	r24
 884:	80 7f       	andi	r24, 0xF0	; 240
 886:	e0 df       	rcall	.-64     	; 0x848 <lcd_out>
 888:	80 e7       	ldi	r24, 0x70	; 112
 88a:	8a 95       	dec	r24
 88c:	f1 f7       	brne	.-4      	; 0x88a <lcd_command+0x12>
	
	_delay_us( LCD_COMMAND_US );
}
 88e:	cf 91       	pop	r28
 890:	08 95       	ret

00000892 <lcd_clear>:

////////////////////////////////////////////////////////////////////////////////
// Sendet den Befehl zur Löschung des Displays
void lcd_clear( void )
{
	lcd_command( LCD_CLEAR_DISPLAY );
 892:	81 e0       	ldi	r24, 0x01	; 1
 894:	f1 df       	rcall	.-30     	; 0x878 <lcd_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 896:	8f e9       	ldi	r24, 0x9F	; 159
 898:	9f e0       	ldi	r25, 0x0F	; 15
 89a:	01 97       	sbiw	r24, 0x01	; 1
 89c:	f1 f7       	brne	.-4      	; 0x89a <lcd_clear+0x8>
 89e:	00 c0       	rjmp	.+0      	; 0x8a0 <lcd_clear+0xe>
 8a0:	00 00       	nop
 8a2:	08 95       	ret

000008a4 <lcd_init>:
{
	// verwendete Pins auf Ausgang schalten
	uint8_t pins = (0x0F << LCD_DB) |           // 4 Datenleitungen
	(1<<LCD_RS) |                // R/S Leitung
	(1<<LCD_EN);                 // Enable Leitung
	LCD_DDR |= pins;
 8a4:	84 b3       	in	r24, 0x14	; 20
 8a6:	8f 63       	ori	r24, 0x3F	; 63
 8a8:	84 bb       	out	0x14, r24	; 20
	
	// initial alle Ausgänge auf Null
	LCD_PORT &= ~pins;
 8aa:	85 b3       	in	r24, 0x15	; 21
 8ac:	80 7c       	andi	r24, 0xC0	; 192
 8ae:	85 bb       	out	0x15, r24	; 21
 8b0:	8f e2       	ldi	r24, 0x2F	; 47
 8b2:	95 e7       	ldi	r25, 0x75	; 117
 8b4:	01 97       	sbiw	r24, 0x01	; 1
 8b6:	f1 f7       	brne	.-4      	; 0x8b4 <lcd_init+0x10>
 8b8:	00 c0       	rjmp	.+0      	; 0x8ba <lcd_init+0x16>
 8ba:	00 00       	nop
	
	// warten auf die Bereitschaft des LCD
	_delay_ms( LCD_BOOTUP_MS );
	
	// Soft-Reset muss 3mal hintereinander gesendet werden zur Initialisierung
	lcd_out( LCD_SOFT_RESET );
 8bc:	80 e3       	ldi	r24, 0x30	; 48
 8be:	c4 df       	rcall	.-120    	; 0x848 <lcd_out>
 8c0:	8f e0       	ldi	r24, 0x0F	; 15
 8c2:	97 e2       	ldi	r25, 0x27	; 39
 8c4:	01 97       	sbiw	r24, 0x01	; 1
 8c6:	f1 f7       	brne	.-4      	; 0x8c4 <lcd_init+0x20>
 8c8:	00 c0       	rjmp	.+0      	; 0x8ca <lcd_init+0x26>
 8ca:	00 00       	nop
	_delay_ms( LCD_SOFT_RESET_MS1 );
	
	lcd_enable();
 8cc:	b6 df       	rcall	.-148    	; 0x83a <lcd_enable>
 8ce:	8f ec       	ldi	r24, 0xCF	; 207
 8d0:	97 e0       	ldi	r25, 0x07	; 7
 8d2:	01 97       	sbiw	r24, 0x01	; 1
 8d4:	f1 f7       	brne	.-4      	; 0x8d2 <lcd_init+0x2e>
 8d6:	00 c0       	rjmp	.+0      	; 0x8d8 <lcd_init+0x34>
 8d8:	00 00       	nop
	_delay_ms( LCD_SOFT_RESET_MS2 );
	
	lcd_enable();
 8da:	af df       	rcall	.-162    	; 0x83a <lcd_enable>
 8dc:	8f ec       	ldi	r24, 0xCF	; 207
 8de:	97 e0       	ldi	r25, 0x07	; 7
 8e0:	01 97       	sbiw	r24, 0x01	; 1
 8e2:	f1 f7       	brne	.-4      	; 0x8e0 <lcd_init+0x3c>
 8e4:	00 c0       	rjmp	.+0      	; 0x8e6 <lcd_init+0x42>
 8e6:	00 00       	nop
	_delay_ms( LCD_SOFT_RESET_MS3 );
	
	// 4-bit Modus aktivieren
	lcd_out( LCD_SET_FUNCTION |
 8e8:	80 e2       	ldi	r24, 0x20	; 32
 8ea:	ae df       	rcall	.-164    	; 0x848 <lcd_out>
 8ec:	8f e0       	ldi	r24, 0x0F	; 15
 8ee:	97 e2       	ldi	r25, 0x27	; 39
 8f0:	01 97       	sbiw	r24, 0x01	; 1
 8f2:	f1 f7       	brne	.-4      	; 0x8f0 <lcd_init+0x4c>
 8f4:	00 c0       	rjmp	.+0      	; 0x8f6 <lcd_init+0x52>
 8f6:	00 00       	nop
	LCD_FUNCTION_4BIT );
	_delay_ms( LCD_SET_4BITMODE_MS );
	
	// 4-bit Modus / 2 Zeilen / 5x7
	lcd_command( LCD_SET_FUNCTION |
 8f8:	88 e2       	ldi	r24, 0x28	; 40
 8fa:	be df       	rcall	.-132    	; 0x878 <lcd_command>
	LCD_FUNCTION_4BIT |
	LCD_FUNCTION_2LINE |
	LCD_FUNCTION_5X7 );
	
	// Display ein / Cursor aus / Blinken aus
	lcd_command( LCD_SET_DISPLAY |
 8fc:	8c e0       	ldi	r24, 0x0C	; 12
 8fe:	bc df       	rcall	.-136    	; 0x878 <lcd_command>
	LCD_DISPLAY_ON |
	LCD_CURSOR_OFF |
	LCD_BLINKING_OFF);
	
	// Cursor inkrement / kein Scrollen
	lcd_command( LCD_SET_ENTRY |
 900:	86 e0       	ldi	r24, 0x06	; 6
 902:	ba df       	rcall	.-140    	; 0x878 <lcd_command>
	LCD_ENTRY_INCREASE |
	LCD_ENTRY_NOSHIFT );
	
	lcd_clear();
 904:	c6 df       	rcall	.-116    	; 0x892 <lcd_clear>
 906:	08 95       	ret

00000908 <lcd_setcursor>:

void lcd_setcursor( uint8_t x, uint8_t y )
{
	uint8_t data;
	
	switch (y)
 908:	62 30       	cpi	r22, 0x02	; 2
 90a:	59 f0       	breq	.+22     	; 0x922 <lcd_setcursor+0x1a>
 90c:	18 f4       	brcc	.+6      	; 0x914 <lcd_setcursor+0xc>
 90e:	61 30       	cpi	r22, 0x01	; 1
 910:	31 f0       	breq	.+12     	; 0x91e <lcd_setcursor+0x16>
 912:	08 95       	ret
 914:	63 30       	cpi	r22, 0x03	; 3
 916:	39 f0       	breq	.+14     	; 0x926 <lcd_setcursor+0x1e>
 918:	64 30       	cpi	r22, 0x04	; 4
 91a:	39 f0       	breq	.+14     	; 0x92a <lcd_setcursor+0x22>
 91c:	08 95       	ret
	{
		case 1:    // 1. Zeile
		data = LCD_SET_DDADR + LCD_DDADR_LINE1 + x;
 91e:	80 58       	subi	r24, 0x80	; 128
		break;
 920:	05 c0       	rjmp	.+10     	; 0x92c <lcd_setcursor+0x24>
		
		case 2:    // 2. Zeile
		data = LCD_SET_DDADR + LCD_DDADR_LINE2 + x;
 922:	88 55       	subi	r24, 0x58	; 88
		break;
 924:	03 c0       	rjmp	.+6      	; 0x92c <lcd_setcursor+0x24>
		
		case 3:    // 3. Zeile
		data = LCD_SET_DDADR + LCD_DDADR_LINE3 + x;
 926:	8c 56       	subi	r24, 0x6C	; 108
		break;
 928:	01 c0       	rjmp	.+2      	; 0x92c <lcd_setcursor+0x24>
		
		case 4:    // 4. Zeile
		data = LCD_SET_DDADR + LCD_DDADR_LINE4 + x;
 92a:	8c 52       	subi	r24, 0x2C	; 44
		
		default:
		return;                                   // für den Fall einer falschen Zeile
	}
	
	lcd_command( data );
 92c:	a5 df       	rcall	.-182    	; 0x878 <lcd_command>
 92e:	08 95       	ret

00000930 <lcd_string>:

////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD

void lcd_string(const char *data )
{
 930:	cf 93       	push	r28
 932:	df 93       	push	r29
 934:	ec 01       	movw	r28, r24
	while( *data != '\0' )
 936:	88 81       	ld	r24, Y
 938:	88 23       	and	r24, r24
 93a:	29 f0       	breq	.+10     	; 0x946 <lcd_string+0x16>
 93c:	21 96       	adiw	r28, 0x01	; 1
	lcd_data( *data++ );
 93e:	8e df       	rcall	.-228    	; 0x85c <lcd_data>
////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD

void lcd_string(const char *data )
{
	while( *data != '\0' )
 940:	89 91       	ld	r24, Y+
 942:	81 11       	cpse	r24, r1
 944:	fc cf       	rjmp	.-8      	; 0x93e <lcd_string+0xe>
	lcd_data( *data++ );
}
 946:	df 91       	pop	r29
 948:	cf 91       	pop	r28
 94a:	08 95       	ret

0000094c <strcat>:
 94c:	fb 01       	movw	r30, r22
 94e:	dc 01       	movw	r26, r24
 950:	0d 90       	ld	r0, X+
 952:	00 20       	and	r0, r0
 954:	e9 f7       	brne	.-6      	; 0x950 <strcat+0x4>
 956:	11 97       	sbiw	r26, 0x01	; 1
 958:	01 90       	ld	r0, Z+
 95a:	0d 92       	st	X+, r0
 95c:	00 20       	and	r0, r0
 95e:	e1 f7       	brne	.-8      	; 0x958 <strcat+0xc>
 960:	08 95       	ret

00000962 <strcpy>:
 962:	fb 01       	movw	r30, r22
 964:	dc 01       	movw	r26, r24
 966:	01 90       	ld	r0, Z+
 968:	0d 92       	st	X+, r0
 96a:	00 20       	and	r0, r0
 96c:	e1 f7       	brne	.-8      	; 0x966 <strcpy+0x4>
 96e:	08 95       	ret

00000970 <_exit>:
 970:	f8 94       	cli

00000972 <__stop_program>:
 972:	ff cf       	rjmp	.-2      	; 0x972 <__stop_program>
